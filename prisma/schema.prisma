generator client {
  provider = "prisma-client-js"
  // output   = "../generated/prisma"
}

// Datasource
datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL_SQLITE")
}

// datasource db {
//   provider = "postgres"
//   url      = env("DATABASE_URL")
// }

model User {
  id        String @id @default(uuid())
  firstName String
  lastName  String
  email     String @unique
  password  String

  // Relacionamentos
  address   Address? @relation(fields: [addressId], references: [id])
  addressId Int?

  fishingTrips FishingTrip[] // N:N — um usuário pode participar de várias pescarias
  tripExpenses TripExpense[] // 1:N — um usuário pode ter várias despesas em pescarias

  fishingPartners   FishingPartner[] @relation("UserFishingPartners")
  fishingPartnersOf FishingPartner[] @relation("PartnerFishingPartners")
}

model TripExpense {
  id       Int             @id @default(autoincrement())
  value    Float
  category ExpenseCategory

  // Relacionamentos
  user   User   @relation(fields: [userId], references: [id])
  userId String

  fishingTrip   FishingTrip @relation(fields: [fishingTripId], references: [id])
  fishingTripId Int
}

model Address {
  id      Int    @id @default(autoincrement())
  address String
  city    String
  state   String
  mapUrl  String // Ex: https://www.google.com/maps/dir//travessa%20ibirarema%2012...

  // Relacionamentos
  users       User[] // vários usuários podem compartilhar um endereço
  fishingSpot FishingSpot? // 1:1 — um endereço pode estar vinculado a um ponto de pesca
  guides      Guide[] // vários guias podem ter o mesmo endereço (ex: mesma marina)
}

model Tag {
  id      Int    @id @default(autoincrement())
  tagName String

  // Relacionamentos
  guides Guide[] // uma tag pode estar em vários guias/marinas
}

model FishingPartner {
  id        Int    @id @default(autoincrement())
  userId    String
  partnerId String

  status    String   @default("pending") // pending, accepted, blocked, etc.
  createdAt DateTime @default(now())

  user    User @relation("UserFishingPartners", fields: [userId], references: [id])
  partner User @relation("PartnerFishingPartners", fields: [partnerId], references: [id])

  @@unique([userId, partnerId]) // Evita duplicidade de parceria
}

model Guide {
  id          Int       @id @default(autoincrement())
  name        String
  description String
  rating      Float
  type        GuideType // MARINA | GUIA_DE_PESCA | BARQUEIRO
  whatsapp    String?
  phone       String?

  // Relacionamentos
  tags      Tag[] // várias tags por guia
  address   Address @relation(fields: [addressId], references: [id])
  addressId Int

  fishingTrips FishingTrip[] // 1:N — um guia pode estar em várias pescarias
}

model FishingSpot {
  id          Int      @id @default(autoincrement())
  name        String
  rating      Float
  description String
  type        SpotType // EMBARCADO | PESCA_E_PAGUE | BEIRA_RIO

  // Relacionamentos
  fishingTrips FishingTrip[] // várias pescarias podem ocorrer no mesmo local

  address   Address @relation(fields: [addressId], references: [id])
  addressId Int     @unique
}

model FishingTrip {
  id   Int      @id @default(autoincrement())
  date DateTime

  totalExpense Float
  status       TripStatus // PENDING | FINISHED | CANCELED

  // Relacionamentos
  users User[] // N:N — vários usuários podem participar da mesma pescaria

  guide   Guide @relation(fields: [guideId], references: [id])
  guideId Int

  fishingSpot   FishingSpot @relation(fields: [fishingSpotId], references: [id])
  fishingSpotId Int

  tripExpenses TripExpense[] // 1:N — várias despesas podem ocorrer na mesma pescaria
}

// ===== ENUMS =====

enum TripStatus {
  PENDING
  FINISHED
  CANCELED
}

enum SpotType {
  EMBARCADO
  PESCA_E_PAGUE
  BEIRA_RIO
}

enum GuideType {
  MARINA
  GUIA_DE_PESCA
  BARQUEIRO
}

enum ExpenseCategory {
  VEICULO
  ISCAS
  EMBARCACAO
  PESQUEIRO
  EQUIPAMENTO
  OUTROS
}
